/*
 * queryServer.h
 *
 *  Created on: 4. 7. 2016
 *      Author: ondra
 */

#ifndef LIGHTCOUCH_QUERYSERVER_H_09888912AE57CCE472
#define LIGHTCOUCH_QUERYSERVER_H_09888912AE57CCE472
#include <lightspeed/base/containers/constStr.h>
#include <lightspeed/base/streams/fileio.h>
#include <lightspeed/utils/json.h>
#include "lightspeed/base/framework/app.h"

#include "lightspeed/base/containers/stringKey.h"

#include "lightspeed/base/containers/map.h"
#include "lightspeed/base/memory/sharedPtr.h"

#include "couchDB.h"
#include "document.h"
#include "object.h"
#include "query.h"


namespace LightCouch {


using namespace LightSpeed;

///Emit function - object is passed to the map() function and function should call it to emit result to the view
class IEmitFn {
public:
	///Emit current document to the view without key and value.
	/** You can use this function to build sets of document with some feature.
	 Both key and value is set to null
	 */
	virtual void operator()() = 0;

	///Emit current document under specified key
	/**
	 * @param key key value. You can emit multiple documents under single key. You can use
	 * multicollum keys (emit as an array). You can also use object as key, however be careful,
	 * because LightCouch doesn't maintain order of fields. Fields are always ordered.
	 */
	virtual void operator()(const ConstValue &key) = 0;
	///Emit current document under specified key with a value
	/**
	 * @param key key value. You can emit multiple documents under single key. You can use
	 * multicollum keys (emit as an array). You can also use object as key, however be careful,
	 * because LightCouch doesn't maintain order of fields. Fields are always ordered.
	 * @param value value.
	 */
	virtual void operator()(const ConstValue &key, const ConstValue &value) = 0;
};

///Base class for every QueryServer's handler
class QueryServerHandler {
public:

	///JSON factory for easy creation of the JSON objects
	/** Object is initialized during registration to the query server */
	Json json;

	QueryServerHandler():json(JSON::PFactory(null)) {}

	///Changes json factory
	void setJson(const Json &json) {this->json = json;}
	///Each view must have version.
	/** Everytime map or reduce function is modified, the version should be updated.
	 * Changing version triggers two events. First the cauchdb regenerates the view. Second,
	 * it also restarts the query server.
	 *
	 * @return version. Value is considered static, it should not change over time.
	 */
	virtual natural version() const = 0;

	virtual ~QueryServerHandler() {}

};

///Abstract map-reduce function (base class)
/** Because map-reduce function is complex, you should define this function as an object
 * which implements all three phases of map-reduce feature.
 *
 * If you need to implement only map function without reduce, use AbstractMapFn instead
 */
class AbstractViewBase: public QueryServerHandler {
public:

	enum ReduceMode {
		///View has no reduce
		rmNone,
		///View has defined reduce() and rereduce() functions
		rmFunction,
		///View uses build-in _count function
		rmCount,
		///View uses build-in _sum function
		rmSum,
		///View uses build-in _stats function
		rmStats
	};

	class ReducedRow {
	public:
		///contains value
		const ConstValue value;

		ReducedRow(const ConstValue value):value(value) {}
	};
	///Row - contains single row of view which is being reduced
	class Row: public ReducedRow {
	public:
		///contains document id
		const ConstValue docId;
		///contains key
		const ConstValue key;

		///constructor
		Row(const ConstValue docId,const ConstValue key,const ConstValue value)
			:ReducedRow (value),docId(docId),key(key) {}
	};

	typedef ConstStringT<Row> Rows;
	typedef ConstStringT<ReducedRow> ReducedRows;

	///perform map operation
	/**
	 * @param doc whole document to map
	 * @param emit function to use to emit result
	 */
	virtual void map(const Document &doc, IEmitFn &emit) = 0;
	///function returns true, because object supports reduce
	virtual ReduceMode reduceMode() const {return rmFunction;}
	///called to reduce rows
	/**
	 * @param rows array of rows to reduce
	 * @return reduced result
	 */
	virtual ConstValue reduce(const Rows &rows) = 0;

	///Called when rereduce is required
	/**
	 * Function should reduce already reduced rows. CouchDB can optimize reduce by reducing
	 * per-partes. This function is called to reduce already reduced results.
	 *
	 * @param values array of reduced result
	 * @return reduced result
	 *
	 * @note function can be called by multiple times with already reduced result generated by
	 * previous run.
	 */
	virtual ConstValue rereduce(const ReducedRows &values) = 0;

};

///Abstract map-reduce function
/** Because map-reduce function is complex, you should define this function as an object
 * which implements all three phases of map-reduce feature.
 *
 * If you need to implement only map function without reduce, use AbstractViewMapOnly instead
 *
 * Template class required an argument
 * @tparam ver version number. Everytime map or reduce is changed, version must be changed as well
 * to enforce reindexing of the view. However, without changing the version, the updated
 * code will apply for newly added items
 *
 */

template<natural ver>
class AbstractView: public AbstractViewBase {
public:
	virtual natural version() const override {return ver;}
};


///Abstract map function
/** Map only view with buildin reduce function (performed by couchdb itself)
 *
 *@tparam ver version - see AbstractView
 *@tparam mode Specify reduce mode. It can be rmSum, rmCount or rmStats. You can also specify
 *        rmNone which is implemented in class AbstractViewMapOnly. You should not use
 *        rmFunction, which is default for AbstractView itself
 */
template<natural ver, AbstractViewBase::ReduceMode mode>
class AbstractViewBuildin: public AbstractView<ver> {
public:
	typedef typename AbstractView<ver>::Rows Rows;
	typedef typename AbstractView<ver>::ReducedRows ReducedRows;
	typedef typename AbstractView<ver>::ReduceMode ReduceMode;

	virtual ReduceMode reduceMode() const override {return mode;}
	virtual ConstValue reduce(const Rows &) override {return null;}
	virtual ConstValue rereduce(const ReducedRows &) override {return null;}
};

///Abstract map function
/** Map only view (without reduce)
 *
 * Template class required an argument
 * @tparam ver version number. Everytime map or reduce is changed, version must be changed as well
 * to enforce reindexing of the view. However, without changing the version, the updated
 * code will apply for newly added items
 */
template<natural ver>
class AbstractViewMapOnly: public AbstractViewBuildin<ver, AbstractViewBase::rmNone> {
public:
};


///List function context
class IListContext {
public:
	virtual ~IListContext() {}
	///Receive next row from view
	/**
	 * @return a valid row data, or null if none available. If result is not null, it
	 * can be converted to Row object
	 *
	 * @note function also flushes any data sent by send() function. The response
	 * object in the context is also sent, so any modification in it will not applied.
	 */
	virtual ConstValue getRow() = 0;
	///send text to output
	virtual void send(ConstStrA text) = 0;
	///send json to output
	virtual void send(ConstValue jsonValue) = 0;
	///retrieve view header
	virtual ConstValue getViewHeader() const = 0;
	///Initializes output
	/**
	 * @param headerObject header object, see couchdb documentation about lists
	 *
	 * Function must be called before first getRow() is called, otherwise it is ignored
	 * If called by multiple-times, before getRow(), header fields are merged
	 */
	virtual void start(ConstValue headerObject) = 0;
};

///List function (base class)
/** Use AbstractList */
class AbstractListBase: public QueryServerHandler {
public:
	///List function
	/**
	 * @param list contains interface to enumerate rows
	 *
	 * Works similar as JS version. You receive IListContext through the variable list. You
	 * can call method of this interface inside of the function. The function getRow returns
	 * next row from the view. Object can be converted to Row object.
	 *
	 * According to couchdb's query protocol, the function send() will emit its output
	 * during the getRow is processed. Sends after last row has been received will
	 * be processed on function exit. You don't need to process all rows.
	 */
	virtual void run(IListContext &list, ConstValue request) = 0;
	virtual ~AbstractListBase() {}
};

///show function (base class)
/** Use AbstractShow */
class AbstractShowBase: public QueryServerHandler {
public:
	///Show function
	/**
	 * @param doc document to show
	 * @param request request (see CouchDB documentation)
	 * @return response object
	 */

	virtual ConstValue run(const Document &doc, ConstValue request) = 0;
	virtual ~AbstractShowBase() {}
};

///update function (base class)
/** Use AbstractUpdate */
class AbstractUpdateFnBase: public QueryServerHandler {
public:
	///Update function
	/**
	 * @param doc document to change. Change the document (make it dirty) and the document will be stored
	 *   (note it can be null)
	 * @param request request
	 * @return response object
	 */
	virtual ConstValue run(Document &doc, ConstValue request) = 0;
	virtual ~AbstractUpdateFnBase() {}
};

///Filter function (base class)
/** Use AbstractFilter */
class AbstractFilterBase: public QueryServerHandler {
public:
	///Filter function
	/**
	 * @param doc document
	 * @param request request object
	 * @retval true allow document
	 * @retval false disallow document
	 */
	virtual bool run(const Document &doc, ConstValue request) = 0;
	virtual ~AbstractFilterBase() {}
};

template<natural ver> class AbstractList: public AbstractListBase {
	virtual natural version() const {return ver;}
};
template<natural ver> class AbstractShow: public AbstractShowBase {
	virtual natural version() const {return ver;}
};
template<natural ver> class AbstractUpdateFn: public AbstractUpdateFnBase {
	virtual natural version() const {return ver;}
};
template<natural ver> class AbstractFilter: public AbstractFilterBase {
	virtual natural version() const {return ver;}
};

class QueryServerError: public Exception {
public:
	LIGHTSPEED_EXCEPTIONFINAL;

	QueryServerError(const ProgramLocation &loc, StringA type, StringA explain)
		:Exception(loc),type(type),explain(explain) {}
	const StringA &getType() const;
	const StringA &getExplain() const;
protected:
	StringA type, explain;
	void message(ExceptionMsg &msg) const;

};

class VersionMistmatch: public Exception {
public:
	LIGHTSPEED_EXCEPTIONFINAL;

	VersionMistmatch(const ProgramLocation &loc):Exception(loc) {}
protected:
	void message(ExceptionMsg &msg) const;

};



///Helps to create query server
/** CouchDB allows to define custom query server. This class helps to build custom query server.
 * It implements CouchDB query protocol, transfers it and call functions available on this interface.
 *
 * CouchDB design documents contain execution code. This is not case of C++ query server, because
 * all functions must be already coded. Instead of the code, design document can contain just function
 * name and/or arguments.
 */
class QueryServer {
public:

	///Constructor specified name of this query server
	/**
	 * @param name name of query server. It should match name of query server registered in
	 * couchdb's ini section. This is important if you need to generate design documents
	 * from the QueryServer's function defintions. Otherwise, you can use constructor without argument
	 *
	 * @param path path to query server's application. If path is not empty, it must be
	 *  valid and should contain pathname to the file, which is modified everytime the
	 *  application is updated (i.e. path to the current binary is enough).	 *
	 *  The object will monitor the binary and drops connection anytime the referenced
	 *  binary is updated
	 */
	QueryServer(ConstStrA name, ConstStrW path);


	///Registers view
	/**
 	 * @param viewName name of the view. It can be simple name, or name in the format "ddoc/name". This
 	 * name also appears in the design document.
	 * @param impl pointer to created instance of view. Ownership of the pointer is maintained by
	 * the QueryServer and it is automatically destroyed when QueryServer object dies.
	 */
	void regView(StringA viewName, AbstractViewBase *impl);

	///Registers list
	/**
 	 * @param listName name of the list. It can be simple name, or name in the format "ddoc/name". This
 	 * name also appears in the design document.
	 * @param impl pointer to created instance of the list. Ownership of the pointer is maintained by
	 * the QueryServer and it is automatically destroyed when QueryServer object dies.
	 */
	void regList(StringA listName, AbstractListBase *impl);

	///Register show
	/**
	 *
	 * @param showName name of the show. It can be simple name, or name in the format "ddoc/name". This
 	 * name also appears in the design document.
	 * @param impl pointer to created instance of the list. Ownership of the pointer is maintained by
	 * the QueryServer and it is automatically destroyed when QueryServer object dies.
	 */
	void regShow(StringA showName, AbstractShowBase *impl);

	///Register update function
	/**
	 * Update function allows to update document directly in couchDb server.
	 *
	 * @param updateName name of the update. It can be simple name, or name in the format "ddoc/name". This
 	 * name also appears in the design document.
	 * @param impl pointer to created instance of the list. Ownership of the pointer is maintained by
	 * the QueryServer and it is automatically destroyed when QueryServer object dies.
	 */
	void regUpdateFn(StringA updateName, AbstractUpdateFnBase *impl);

	///Register filter
	/**
	 *
 	 * @param filterName name of the filter. It can be simple name, or name in the format "ddoc/name". This
 	 * name also appears in the design document.
	 * @param impl pointer to created instance of the list. Ownership of the pointer is maintained by
	 * the QueryServer and it is automatically destroyed when QueryServer object dies.
	 */
	void regFilter(StringA filterName, AbstractFilterBase *impl);


	///Starts queryServer's dispatcher
	/**
	 * @param stream reference to input-output stream which will be dispatched
	 */
	void runDispatch(PInOutStream stream);

	///start dispatching from standard input/output
	virtual integer runDispatchStdIO();


	///Generates array of design documents
	/**
	 * @return list of design documents (array). If function's name is in form name1/name2, then
	 * name1 specified name of document. It will put into document _design/name1 as function name2.
	 * If function's name hasn't format specified above, then it will put into document _design/qsname under
	 * its name (where qsname is name of the query server).
	 *
	 * for example
	 * @code
	 * assume that query server's name is "userserver"
	 * user/by_login =>  _design/user/_view/by_login
	 * lastlogin => _design/userserver/_view/lastlogin
	 * @endcode
	 *
	 * @note lists functions must be included into same document as views which will be
	 * taken as source. In this case, you need to specify same prefix for view and list
	 *
	 * @code
	 * view:user/by_login + list:user/as_table => _design/user/_list/as_table/by_login
	 * view:lastlogin + list:details => _design/userserver/_list/details/lastlogin
	 * @endcode
	 *
	 */
	ConstValue generateDesignDocuments();


	///synchronizes design documents
	/**
	 *
	 * @param designDocuments design documents generated by function generateDesignDocuments()
	 * @param couch instance of couchDB client
	 *
	 * @note function tries to restart currently running QueryServer by accessing the changed
	 * view. This can cause that error 500 will appear in the CouchDB log file. This error is
	 * ignored. Because of this, function cannot check, whether restart has been successful.
	 */
	static void syncDesignDocuments(ConstValue designDocuments, CouchDB &couch, CouchDB::DesignDocUpdateRule updateRule = CouchDB::ddurOverwrite);



	Json json;

protected:

	///Checks, whether application has been updated.
	/** The function compares modification time of the program with stored time
	 * the differ, exception VersionMistmatchException is thrown.
	 *
	 * Function is called during "reset" phase
	 */
	virtual void checkAppUpdate();




	typedef StringKey<StringA>  StrKey;
	typedef Map<StrKey, SharedPtr<AbstractViewBase> > RegView;
	typedef Map<StrKey, SharedPtr<AbstractShowBase> > RegShowFn;
	typedef Map<StrKey, SharedPtr<AbstractListBase> > RegListFn;
	typedef Map<StrKey, SharedPtr<AbstractUpdateFnBase> > RegUpdateFn;
	typedef Map<StrKey, SharedPtr<AbstractFilterBase> > RegFilterFn;

	RegView views;
	RegShowFn shows;
	RegListFn lists;
	RegUpdateFn updates;
	RegFilterFn filters;
	StringA qserverName;
	String qserverPath;
	Container ddcache;

	AutoArray<AbstractViewBase::Row> rowBuffer;
	AutoArray<AbstractViewBase::ReducedRow> valueBuffer;

	TimeStamp appUpdateTime;

private:
	struct PreparedMap {
		AbstractViewBase &fn;

		PreparedMap(AbstractViewBase &fn):fn(fn) {}
	};
	AutoArray<PreparedMap> preparedMaps;

	ConstValue commandReset(const ConstValue &req);
	ConstValue commandAddLib(const ConstValue &req);
	ConstValue commandAddFun(const ConstValue &req);
	ConstValue commandMapDoc(const ConstValue &req);
	ConstValue commandReduce(const ConstValue &req);
	ConstValue commandReReduce(const ConstValue &req);
	ConstValue commandDDoc(const ConstValue &req, const PInOutStream &stream);

	ConstValue commandShow(const ConstValue &fn, const ConstValue &args);
	ConstValue commandList(const ConstValue &fn, const ConstValue &args, const PInOutStream &stream);
	ConstValue commandUpdate(const ConstValue &fn, const ConstValue &args);
	ConstValue commandView(const ConstValue &fn, const ConstValue &args);
	ConstValue commandFilter(const ConstValue &fn, const ConstValue &args);




	ConstValue compileDesignDocument(const ConstValue &document);
	template<typename T>
	ConstValue compileDesignSection(T &reg, const ConstValue &section, ConstStrA sectionName);

	Value createDesignDocument(Value container, ConstStrA fnName, ConstStrA &suffix);
};


class QueryServerApp : public LightSpeed::App, public QueryServer {
public:
	QueryServerApp(ConstStrA name, integer priority = 0);

	virtual integer start(const Args &args);

	///Start function of query server
	/**
	 * The only function query server need to implement. However this is also only place, where
	 * to call various regXXXFn() to register native functions
	 *
	 * @param args arguments passed from command line
	 * @return function must return zero to continue query server, other value immediately exits
	 * process with given value as the exit code
	 */
	virtual integer initServer(const LightSpeed::App::Args &args) = 0;

};

} /* namespace LightCouch */

#endif /* LIGHTCOUCH_QUERYSERVER_H_09888912AE57CCE472 */

